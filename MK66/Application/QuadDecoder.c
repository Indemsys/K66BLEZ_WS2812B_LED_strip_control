#include "App.h"


static T_qdec_cbl              qdec_cbl;
static T_qdec_diagnostic       qdec_diagn;
static T_app_qdec_isr          app_qdec_isr;


static void QDEC_isr(uint32_t dir);
/*-------------------------------------------------------------------------------------------------------------
  Инициализация датчика скорости - положения
  Датчик выполнен на основе квадратурного энкодера с использованием таймера FTM1

  Внимание!!! Модуль таймера FTM1 имеет только 2-а канала capture-compare.
  Попытка записи или чтения несуществующих регистров приводит к зависанию задачи
-------------------------------------------------------------------------------------------------------------*/
void Init_QuadratureDecoder(void)
{
  FTM1_init_QDEC(QDEC_isr);
}

/*-------------------------------------------------------------------------------------------------------------
  Обработчик прерывания таймера FTM1
  Прерывания происходят при переполнении счетчика
  Функция обработчика вести счетчик переполнений
-------------------------------------------------------------------------------------------------------------*/
static void QDEC_isr(uint32_t dir)
{

  // Определяем направление вращения при котором произошло переполнение
  if (dir)
  {
    // Переполнение при счете вверх
    qdec_cbl.tacho_counter++;
    qdec_cbl.dir_sign = 1;
  }
  else
  {
    // Переполнение при счете вниз
    qdec_cbl.tacho_counter--;
    qdec_cbl.dir_sign = (-1);
  }

  qdec_cbl.idle_cnt = 0; // Сбрасываем счетчик интервала IDLE

  // Фиксируем время возникновения прерываний для последующего расчета времени вращения
  qdec_diagn.ticktime_prev = qdec_diagn.ticktime;
  _time_get_ticks(&qdec_diagn.ticktime);

  if (app_qdec_isr != 0) app_qdec_isr(qdec_cbl.tacho_counter);


  // В отладочных целях следим за статистикой импульсов
  if (qdec_diagn.enabled)
  {
    uint32_t t;
    bool   overfl;
    t = _time_diff_microseconds(&qdec_diagn.ticktime, &qdec_diagn.ticktime_prev, &overfl);
    if (t > qdec_diagn.max_t) qdec_diagn.max_t = t;
    if (t < qdec_diagn.min_t) qdec_diagn.min_t = t;
    qdec_diagn.smpl_cnt++;
  }
}

/*------------------------------------------------------------------------------



 \return T_qdec_cbl*
 ------------------------------------------------------------------------------*/
T_qdec_cbl* QDEC_get_cbl(void)
{
  return &qdec_cbl;
}

/*------------------------------------------------------------------------------



 \return T_qdec_diagnostic*
 ------------------------------------------------------------------------------*/
T_qdec_diagnostic* QDEC_get_diagnostic(void)
{
  return &qdec_diagn;
}


/*------------------------------------------------------------------------------
   Увеличить счетчик интервала отсутствия сигнала с энкодера

   Вызывается из периодической задачи с достаточно высоким приоритетом чтобы счет был надежным
 ------------------------------------------------------------------------------*/
void QDEC_increment_idle_cnt(void)
{
  qdec_cbl.idle_cnt++;
}
/*------------------------------------------------------------------------------
 Установливаем обработчик от приложения


 \param isr
 ------------------------------------------------------------------------------*/
void QDEC_set_positioning_calback(T_app_qdec_isr isr)
{
  app_qdec_isr = isr;
}


/*-------------------------------------------------------------------------------------------------------------
  Получить позицию квадратичного декодера и результат измерения длительности последнего тахометрического интервала
-------------------------------------------------------------------------------------------------------------*/
void QDEC_get_ticks(MQX_TICK_STRUCT *tickt_prev, MQX_TICK_STRUCT *tickt)
{
  _int_disable();
  if (tickt_prev != 0)
  {
    *tickt_prev = qdec_diagn.ticktime_prev;
  }
  if (tickt != 0)
  {
    *tickt = qdec_diagn.ticktime;
  }
  _int_enable();
}

/*-------------------------------------------------------------------------------------------------------------
  Рестартовать статистику декодера
-------------------------------------------------------------------------------------------------------------*/
void QDEC_diagnostic_restart(void)
{
  _int_disable();
  qdec_diagn.smpl_cnt = 0;
  qdec_diagn.max_t = 0;
  qdec_diagn.min_t = 0xFFFFFFFF;
  qdec_diagn.enabled = 1;
  _int_enable();
}



/*-----------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------*/
void QDEC_reset_counter(void)
{
  qdec_cbl.tacho_counter = 0;
}

/*-----------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------*/
int32_t QDEC_get_counter(void)
{
  return qdec_cbl.tacho_counter;
}

/*-----------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------*/
void QDEC_set_couter(int32_t pos)
{
  qdec_cbl.tacho_counter = pos;
}


/*-----------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------*/
int32_t Get_speed(void)
{
  int32_t v;
  v = qdec_cbl.rpm;
  return v;
}

/*-----------------------------------------------------------------------------------------------------
  Получить знак направления
-----------------------------------------------------------------------------------------------------*/
int32_t QDEC_get_dir_sign(void)
{
  int32_t v;
  v = qdec_cbl.dir_sign;
  return v;
}


/*-----------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------*/
int32_t QDEC_get_tacho_interval(void)
{
  int32_t v;
  v = qdec_cbl.puls_len;
  return v;
}




